using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Reflection;
using Avro;
using Avro.Generic;
using Newtonsoft.Json.Linq;

public static class AvroGenericMapper05
{
    public static GenericRecord ToGenericRecord(object obj, RecordSchema schema)
    {
        var record = new GenericRecord(schema);

        foreach (var field in schema.Fields)
        {
            var prop = obj.GetType().GetProperty(field.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            if (prop == null) continue;

            var value = prop.GetValue(obj);
            var avroValue = ConvertToAvroValue(value, field.Schema);
            record.Add(field.Name, avroValue);
        }

        return record;
    }

    private static object ConvertToAvroValue(object value, Schema schema)
    {
        if (schema is UnionSchema unionSchema)
        {
            if (value == null && unionSchema.Schemas.Any(s => s.Tag == Schema.Type.Null))
                return null;

            var actualSchema = unionSchema.Schemas.First(s => s.Tag != Schema.Type.Null);
            return ConvertToAvroValue(value, actualSchema);
        }

        if (value == null)
            throw new InvalidOperationException($"Null value not allowed for schema '{schema.Name}'");

        switch (schema.Tag)
        {
            case Schema.Type.Null:
                return null;

            case Schema.Type.Boolean:
            case Schema.Type.Int:
            case Schema.Type.Long:
            case Schema.Type.Float:
            case Schema.Type.Double:
            case Schema.Type.String:
            case Schema.Type.Bytes:
                return value;

            case Schema.Type.Record:
                return ToGenericRecord(value, (RecordSchema)schema);

            case Schema.Type.Array:
                var arraySchema = (ArraySchema)schema;
                var list = new List<object>();
                foreach (var item in (IEnumerable)value)
                    list.Add(ConvertToAvroValue(item, arraySchema.ItemSchema));
                return list;

            case Schema.Type.Enum:
                return new GenericEnum((EnumSchema)schema, value.ToString());

            case Schema.Type.Map:
                var mapSchema = (MapSchema)schema;
                var dict = new Dictionary<string, object>();
                var source = value as IDictionary ?? (value is JObject jObj ? jObj.ToObject<Dictionary<string, object>>() : null);
                if (source != null)
                {
                    foreach (DictionaryEntry kv in source)
                        dict[kv.Key.ToString()] = ConvertToAvroValue(kv.Value, mapSchema.ValueSchema);
                    return dict;
                }
                throw new InvalidCastException("Expected IDictionary or JObject for Avro map");

            case Schema.Type.Logical:
                return ConvertLogicalToAvro(value, (LogicalSchema)schema);

            default:
                throw new NotSupportedException($"Unsupported schema type for serialization: {schema.Tag}");
        }
    }

    private static object ConvertLogicalToAvro(object value, LogicalSchema logicalSchema)
    {
        switch (logicalSchema.LogicalTypeName)
        {
            case "timestamp-millis":
                if (value is DateTime dt)
                {
                    var utc = dt.Kind == DateTimeKind.Unspecified
                        ? DateTime.SpecifyKind(dt, DateTimeKind.Utc)
                        : dt.ToUniversalTime();
                    return (long)(utc - DateTime.UnixEpoch).TotalMilliseconds;
                }
                throw new InvalidCastException("Expected DateTime for timestamp-millis");

            default:
                throw new NotSupportedException($"Unsupported logical type: {logicalSchema.LogicalTypeName}");
        }
    }

    public static object FromGenericRecord(GenericRecord record, Type targetType)
    {
        var instance = Activator.CreateInstance(targetType);

        foreach (var field in record.Schema.Fields)
        {
            var prop = targetType.GetProperty(field.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            if (prop == null || !prop.CanWrite) continue;

            var avroValue = record[field.Name];
            var clrValue = ConvertToClrValue(avroValue, prop.PropertyType, field.Schema);
            prop.SetValue(instance, clrValue);
        }

        return instance;
    }

    private static object ConvertToClrValue(object value, Type targetType, Schema schema)
    {
        if (schema is UnionSchema union)
        {
            if (value == null) return null;
            var actualSchema = union.Schemas.First(s => s.Tag != Schema.Type.Null);
            return ConvertToClrValue(value, targetType, actualSchema);
        }

        if (value == null) return null;

        switch (schema.Tag)
        {
            case Schema.Type.Null:
                return null;

            case Schema.Type.Boolean:
            case Schema.Type.Int:
            case Schema.Type.Long:
            case Schema.Type.Float:
            case Schema.Type.Double:
            case Schema.Type.String:
            case Schema.Type.Bytes:
                return Convert.ChangeType(value, Nullable.GetUnderlyingType(targetType) ?? targetType);

            case Schema.Type.Record:
                return FromGenericRecord((GenericRecord)value, targetType);

            case Schema.Type.Array:
                var arraySchema = (ArraySchema)schema;
                var itemType = targetType.IsArray
                    ? targetType.GetElementType()
                    : targetType.GetGenericArguments().FirstOrDefault() ?? typeof(object);

                var list = (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(itemType));
                foreach (var item in (IEnumerable)value)
                    list.Add(ConvertToClrValue(item, itemType, arraySchema.ItemSchema));

                if (targetType.IsArray)
                {
                    var arr = Array.CreateInstance(itemType, list.Count);
                    list.CopyTo(arr, 0);
                    return arr;
                }

                return list;

            case Schema.Type.Enum:
                return Enum.Parse(targetType, value.ToString());

            case Schema.Type.Map:
                var mapSchema = (MapSchema)schema;
                if (targetType == typeof(JObject))
                {
                    var rawDict = new Dictionary<string, object>();
                    foreach (var kv in (IDictionary<string, object>)value)
                        rawDict[kv.Key] = ConvertToClrValue(kv.Value, typeof(object), mapSchema.ValueSchema);
                    return JObject.FromObject(rawDict);
                }
                else
                {
                    var valueType = targetType.GetGenericArguments().LastOrDefault() ?? typeof(object);
                    var dict = (IDictionary)Activator.CreateInstance(typeof(Dictionary<,>).MakeGenericType(typeof(string), valueType));
                    foreach (DictionaryEntry kv in (IDictionary)value)
                        dict[kv.Key.ToString()] = ConvertToClrValue(kv.Value, valueType, mapSchema.ValueSchema);
                    return dict;
                }

            case Schema.Type.Logical:
                return ConvertLogicalToClr(value, (LogicalSchema)schema, targetType);

            default:
                throw new NotSupportedException($"Unsupported schema type for deserialization: {schema.Tag}");
        }
    }

    private static object ConvertLogicalToClr(object value, LogicalSchema schema, Type targetType)
    {
        switch (schema.LogicalTypeName)
        {
            case "timestamp-millis":
                var millis = Convert.ToInt64(value);
                return DateTime.UnixEpoch.AddMilliseconds(millis).ToLocalTime();

            default:
                throw new NotSupportedException($"Logical type not supported: {schema.LogicalTypeName}");
        }
    }
}
