using Avro.Generic;
using Avro;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

public static class ConfluentAvroConverter
{
    public static string GenerateSchema(Type type, string namespaceName = "example.avro")
    {
        return GenerateSchemaInternal(type, namespaceName);
    }

    public static GenericRecord ConvertToGenericRecord(object obj, RecordSchema schema)
    {
        var record = new GenericRecord(schema);

        foreach (var field in schema.Fields)
        {
            var prop = obj.GetType().GetProperty(field.Name);
            if (prop == null) continue;

            var value = prop.GetValue(obj);
            var converted = ConvertValue(value, field.Schema);
            record.Add(field.Name, converted);
        }

        return record;
    }

    private static object ConvertValue(object value, Schema schema)
    {
        if (value == null) return null;

        switch (schema.Tag)
        {
            case Schema.Type.Null:
            case Schema.Type.Boolean:
            case Schema.Type.Int:
            case Schema.Type.Long:
            case Schema.Type.Float:
            case Schema.Type.Double:
            case Schema.Type.String:
            case Schema.Type.Bytes:
                return value;

            case Schema.Type.Record:
                return ConvertToGenericRecord(value, (RecordSchema)schema);

            case Schema.Type.Array:
                var arraySchema = (ArraySchema)schema;
                var list = new List<object>();
                foreach (var item in (IEnumerable)value)
                {
                    list.Add(ConvertValue(item, arraySchema.ItemSchema));
                }
                return list;

            case Schema.Type.Union:
                var unionSchema = (UnionSchema)schema;
                var actualSchema = unionSchema.Schemas.First(s => s.Tag != Schema.Type.Null);
                return ConvertValue(value, actualSchema);

            default:
                throw new NotSupportedException($"Unsupported schema type: {schema.Tag}");
        }
    }

    private static string GenerateSchemaInternal(Type type, string ns)
    {
        if (type == typeof(string)) return "\"string\"";
        if (type == typeof(int)) return "\"int\"";
        if (type == typeof(long)) return "\"long\"";
        if (type == typeof(bool)) return "\"boolean\"";
        if (type == typeof(float)) return "\"float\"";
        if (type == typeof(double)) return "\"double\"";
        if (type == typeof(byte[])) return "\"bytes\"";

        if (typeof(IEnumerable).IsAssignableFrom(type) && type != typeof(string))
        {
            Type itemType = type.IsArray ? type.GetElementType() : type.GetGenericArguments().FirstOrDefault();
            return $"{{\"type\":\"array\", \"items\":{GenerateSchemaInternal(itemType, ns)}}}";
        }

        // Complex object
        var fields = type.GetProperties()
            .Select(p =>
            {
                var fieldType = GenerateSchemaInternal(p.PropertyType, ns);
                return $"{{\"name\": \"{p.Name}\", \"type\": {fieldType}}}";
            });

        return $@"{{
            ""type"": ""record"",
            ""name"": ""{type.Name}"",
            ""namespace"": ""{ns}"",
            ""fields"": [{string.Join(",", fields)}]
        }}";
    }
}
