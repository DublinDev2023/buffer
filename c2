using Avro;
using Avro.Generic;
using Avro.Specific;
using Avro.Util;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;

public static class AvroMapper
{
    public static T MapGenericRecordTo<T>(GenericRecord record) where T : new()
    {
        return (T)MapToType(record, typeof(T));
    }

    private static object MapToType(object avroObject, Type targetType)
    {
        if (avroObject == null)
            return null;

        if (avroObject is GenericRecord record)
        {
            var result = Activator.CreateInstance(targetType);
            foreach (var field in record.Schema.Fields)
            {
                var prop = targetType
                    .GetProperties(BindingFlags.Instance | BindingFlags.Public)
                    .FirstOrDefault(p => string.Equals(p.Name, field.Name, StringComparison.OrdinalIgnoreCase));

                if (prop == null || !record.TryGetValue(field.Name, out var value))
                    continue;

                object mappedValue = MapFieldValue(value, prop.PropertyType);
                prop.SetValue(result, mappedValue);
            }

            return result;
        }

        return MapFieldValue(avroObject, targetType);
    }

    private static object MapFieldValue(object value, Type targetType)
    {
        if (value == null)
            return null;

        // Handle Avro union type
        if (value is Union union)
            value = union.Value;

        if (value == null)
            return null;

        // Handle logical values
        if (value is DateTime dt && targetType == typeof(DateTime))
            return dt;

        if (value is decimal dec && targetType == typeof(decimal))
            return dec;

        if (value is string str && targetType == typeof(Guid))
            return Guid.Parse(str);

        if (value is GenericRecord nestedRecord)
        {
            return MapToType(nestedRecord, targetType);
        }

        // Handle arrays and lists
        if (value is IList avroList && IsEnumerableType(targetType, out var elementType))
        {
            var list = (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(elementType));
            foreach (var item in avroList)
            {
                var mappedItem = MapFieldValue(item, elementType);
                list.Add(mappedItem);
            }

            if (targetType.IsArray)
            {
                var array = Array.CreateInstance(elementType, list.Count);
                list.CopyTo(array, 0);
                return array;
            }

            return list;
        }

        // Handle enums
        if (targetType.IsEnum)
        {
            return Enum.Parse(targetType, value.ToString());
        }

        // Directly assignable
        if (targetType.IsAssignableFrom(value.GetType()))
        {
            return value;
        }

        // Fallback convert
        try
        {
            return Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture);
        }
        catch
        {
            return null;
        }
    }

    private static bool IsEnumerableType(Type type, out Type elementType)
    {
        if (type.IsArray)
        {
            elementType = type.GetElementType();
            return true;
        }

        if (type.IsGenericType &&
            (type.GetGenericTypeDefinition() == typeof(IEnumerable<>) ||
             type.GetGenericTypeDefinition() == typeof(List<>) ||
             type.GetGenericTypeDefinition() == typeof(IList<>)))
        {
            elementType = type.GetGenericArguments()[0];
            return true;
        }

        var iface = type.GetInterfaces()
            .FirstOrDefault(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IEnumerable<>));

        if (iface != null)
        {
            elementType = iface.GetGenericArguments()[0];
            return true;
        }

        elementType = null;
        return false;
    }
}
