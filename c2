using Avro;
using Avro.Generic;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;

public static class AvroMapper9
{
    private static readonly Dictionary<string, Type> KnownLogicalTypes = new()
    {
        { "MyAppData", typeof(MyAppData) }
    };

    public static T MapGenericRecordTo<T>(GenericRecord record) where T : new()
    {
        return (T)MapToType(record, typeof(T));
    }

    private static object MapToType(object avroObject, Type targetType)
    {
        if (avroObject == null)
            return null;

        if (avroObject is GenericRecord record)
        {
            var result = Activator.CreateInstance(targetType);
            foreach (var field in record.Schema.Fields)
            {
                var prop = targetType.GetProperty(field.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (prop == null || !record.TryGetValue(field.Name, out var value))
                    continue;

                object mappedValue = MapFieldValue(value, prop.PropertyType);
                prop.SetValue(result, mappedValue);
            }

            return result;
        }

        return MapFieldValue(avroObject, targetType);
    }

    private static object MapFieldValue(object value, Type targetType)
    {
        if (value == null)
            return null;

        if (value is Union union)
            value = union.Value;

        if (value == null)
            return null;

        if (value is GenericRecord nestedRecord)
        {
            var schemaName = nestedRecord.Schema.Name;

            // Dynamic object-type resolution
            if (targetType == typeof(object) && KnownLogicalTypes.TryGetValue(schemaName, out var resolvedType))
            {
                return MapToType(nestedRecord, resolvedType);
            }

            return MapToType(nestedRecord, targetType);
        }

        if (value is IList list && IsEnumerableType(targetType, out var elementType))
        {
            var resultList = (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(elementType));
            foreach (var item in list)
            {
                resultList.Add(MapFieldValue(item, elementType));
            }

            if (targetType.IsArray)
            {
                var array = Array.CreateInstance(elementType, resultList.Count);
                resultList.CopyTo(array, 0);
                return array;
            }

            return resultList;
        }

        if (targetType.IsEnum)
        {
            return Enum.Parse(targetType, value.ToString());
        }

        if (targetType.IsAssignableFrom(value.GetType()))
        {
            return value;
        }

        try
        {
            return Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture);
        }
        catch
        {
            return null;
        }
    }

    private static bool IsEnumerableType(Type type, out Type elementType)
    {
        if (type.IsArray)
        {
            elementType = type.GetElementType();
            return true;
        }

        if (type.IsGenericType &&
            (type.GetGenericTypeDefinition() == typeof(List<>) ||
             type.GetGenericTypeDefinition() == typeof(IEnumerable<>)))
        {
            elementType = type.GetGenericArguments()[0];
            return true;
        }

        elementType = null;
        return false;
    }
}
