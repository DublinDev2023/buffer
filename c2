using Avro;
using Avro.Generic;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;

public static class AvroMapper11
{
    public static T MapGenericRecordTo<T>(GenericRecord record) where T : new()
    {
        return (T)MapToType(record, typeof(T));
    }

    private static object MapToType(object avroObject, Type targetType)
    {
        if (avroObject == null)
            return null;

        if (avroObject is GenericRecord record)
        {
            var result = Activator.CreateInstance(targetType);
            foreach (var field in record.Schema.Fields)
            {
                var prop = targetType.GetProperty(field.Name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (prop == null || !record.TryGetValue(field.Name, out var value))
                    continue;

                object mappedValue = MapFieldValue(value, prop.PropertyType);
                prop.SetValue(result, mappedValue);
            }

            return result;
        }

        return MapFieldValue(avroObject, targetType);
    }

    private static object MapFieldValue(object value, Type targetType)
    {
        if (value == null)
            return null;

        if (value is Union union)
            value = union.Value;

        if (value == null)
            return null;

        if (value is GenericRecord nestedRecord)
        {
            // Dynamic type resolution from schema name
            var schemaName = nestedRecord.Schema.Name;
            var resolvedType = FindTypeByName(schemaName) ?? targetType;
            return MapToType(nestedRecord, resolvedType);
        }

        if (value is IList list && IsEnumerableType(targetType, out var elementType))
        {
            var resultList = (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(elementType));
            foreach (var item in list)
                resultList.Add(MapFieldValue(item, elementType));

            return targetType.IsArray
                ? resultList.Cast<object>().ToArray()
                : resultList;
        }

        if (targetType.IsEnum)
            return Enum.Parse(targetType, value.ToString());

        if (targetType.IsAssignableFrom(value.GetType()))
            return value;

        try
        {
            return Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture);
        }
        catch
        {
            return null;
        }
    }

    private static bool IsEnumerableType(Type type, out Type elementType)
    {
        if (type.IsArray)
        {
            elementType = type.GetElementType();
            return true;
        }

        if (type.IsGenericType && typeof(IEnumerable).IsAssignableFrom(type))
        {
            elementType = type.GetGenericArguments()[0];
            return true;
        }

        elementType = null;
        return false;
    }

    private static Type FindTypeByName(string name)
    {
        return AppDomain.CurrentDomain
            .GetAssemblies()
            .SelectMany(a => a.GetTypes())
            .FirstOrDefault(t => t.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
    }
}
